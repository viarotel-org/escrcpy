import{_ as e,c as a,o as s,aj as i}from"./chunks/framework.MtKKuSHf.js";const k=JSON.parse('{"title":"scrcpy for developers","description":"","frontmatter":{},"headers":[],"relativePath":"reference/scrcpy/develop.md","filePath":"en/reference/scrcpy/develop.md","lastUpdated":1747291551000}'),t={name:"reference/scrcpy/develop.md"},n=i(`<h1 id="scrcpy-for-developers" tabindex="-1">scrcpy for developers <a class="header-anchor" href="#scrcpy-for-developers" aria-label="Permalink to &quot;scrcpy for developers&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>This application is composed of two parts:</p><ul><li>the server (<code>scrcpy-server</code>), to be executed on the device,</li><li>the client (the <code>scrcpy</code> binary), executed on the host computer.</li></ul><p>The client is responsible to push the server to the device and start its execution.</p><p>The client and the server establish communication using separate sockets for video, audio and controls. Any of them may be disabled (but not all), so there are 1, 2 or 3 socket(s).</p><p>The server initially sends the device name on the first socket (it is used for the scrcpy window title), then each socket is used for its own purpose. All reads and writes are performed from a dedicated thread for each socket, both on the client and on the server.</p><p>If video is enabled, then the server sends a raw video stream (H.264 by default) of the device screen, with some additional headers for each packet. The client decodes the video frames, and displays them as soon as possible, without buffering (unless <code>--video-buffer=delay</code> is specified) to minimize latency. The client is not aware of the device rotation (which is handled by the server), it just knows the dimensions of the video frames it receives.</p><p>Similarly, if audio is enabled, then the server sends a raw audio stream (OPUS by default) of the device audio output (or the microphone if <code>--audio-source=mic</code> is specified), with some additional headers for each packet. The client decodes the stream, attempts to keep a minimal latency by maintaining an average buffering. The <a href="https://blog.rom1v.com/2023/03/scrcpy-2-0-with-audio/" target="_blank" rel="noreferrer">blog post</a> of the scrcpy v2.0 release gives more details about the audio feature.</p><p>If control is enabled, then the client captures relevant keyboard and mouse events, that it transmits to the server, which injects them to the device. This is the only socket which is used in both direction: input events are sent from the client to the device, and when the device clipboard changes, the new content is sent from the device to the client to support seamless copy-paste.</p><p>Note that the client-server roles are expressed at the application level:</p><ul><li>the server <em>serves</em> video and audio streams, and handle requests from the client,</li><li>the client <em>controls</em> the device through the server.</li></ul><p>However, by default (when <code>--force-adb-forward</code> is not set), the roles are reversed at the network level:</p><ul><li>the client opens a server socket and listen on a port before starting the server,</li><li>the server connects to the client.</li></ul><p>This role inversion guarantees that the connection will not fail due to race conditions without polling.</p><h2 id="server" tabindex="-1">Server <a class="header-anchor" href="#server" aria-label="Permalink to &quot;Server&quot;">​</a></h2><h3 id="privileges" tabindex="-1">Privileges <a class="header-anchor" href="#privileges" aria-label="Permalink to &quot;Privileges&quot;">​</a></h3><p>Capturing the screen requires some privileges, which are granted to <code>shell</code>.</p><p>The server is a Java application (with a <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/Server.java#L193" target="_blank" rel="noreferrer"><code>public static void main(String... args)</code></a> method), compiled against the Android framework, and executed as <code>shell</code> on the Android device.</p><p>To run such a Java application, the classes must be <a href="https://en.wikipedia.org/wiki/Dalvik_(software)" target="_blank" rel="noreferrer"><em>dexed</em></a> (typically, to <code>classes.dex</code>). If <code>my.package.MainClass</code> is the main class, compiled to <code>classes.dex</code>, pushed to the device in <code>/data/local/tmp</code>, then it can be run with:</p><pre><code>adb shell CLASSPATH=/data/local/tmp/classes.dex app_process / my.package.MainClass
</code></pre><p><em>The path <code>/data/local/tmp</code> is a good candidate to push the server, since it&#39;s readable and writable by <code>shell</code>, but not world-writable, so a malicious application may not replace the server just before the client executes it.</em></p><p>Instead of a raw <em>dex</em> file, <code>app_process</code> accepts a <em>jar</em> containing <code>classes.dex</code> (e.g. an <a href="https://en.wikipedia.org/wiki/Android_application_package" target="_blank" rel="noreferrer">APK</a>). For simplicity, and to benefit from the gradle build system, the server is built to an (unsigned) APK (renamed to <code>scrcpy-server.jar</code>).</p><h3 id="hidden-methods" tabindex="-1">Hidden methods <a class="header-anchor" href="#hidden-methods" aria-label="Permalink to &quot;Hidden methods&quot;">​</a></h3><p>Although compiled against the Android framework, <a href="https://stackoverflow.com/a/31908373/1987178" target="_blank" rel="noreferrer">hidden</a> methods and classes are not directly accessible (and they may differ from one Android version to another).</p><p>They can be called using reflection though. The communication with hidden components is provided by <a href="https://github.com/Genymobile/scrcpy/tree/master/server/src/main/java/com/genymobile/scrcpy/wrappers" target="_blank" rel="noreferrer"><em>wrappers</em> classes</a> and <a href="https://github.com/Genymobile/scrcpy/tree/master/server/src/main/aidl" target="_blank" rel="noreferrer">aidl</a>.</p><h3 id="execution" tabindex="-1">Execution <a class="header-anchor" href="#execution" aria-label="Permalink to &quot;Execution&quot;">​</a></h3><p>The server is started by the client basically by executing the following commands:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> scrcpy-server</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /data/local/tmp/scrcpy-server.jar</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> forward</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tcp:27183</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> localabstract:scrcpy</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> shell</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> CLASSPATH=/data/local/tmp/scrcpy-server.jar</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app_process</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> com.genymobile.scrcpy.Server</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.1</span></span></code></pre></div><p>The first argument (<code>2.1</code> in the example) is the client scrcpy version. The server fails if the client and the server do not have the exact same version. The protocol between the client and the server may change from version to version (see <a href="#protocol">protocol</a> below), and there is no backward or forward compatibility (there is no point to use different client and server versions). This check allows to detect misconfiguration (running an older or newer server by mistake).</p><p>It is followed by any number of arguments, in the form of <code>key=value</code> pairs. Their order is irrelevant. The possible keys and associated value types can be found in the <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/Options.java#L181" target="_blank" rel="noreferrer">server</a> and <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/app/src/server.c#L226" target="_blank" rel="noreferrer">client</a> code.</p><p>For example, if we execute <code>scrcpy -m1920 --no-audio</code>, then the server execution will look like this:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># scid is a random number to identify different clients running on the same device</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> shell</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> CLASSPATH=/data/local/tmp/scrcpy-server.jar</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app_process</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> com.genymobile.scrcpy.Server</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> scid=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12345678</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> log_level=info</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> audio=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> max_size=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1920</span></span></code></pre></div><h3 id="components" tabindex="-1">Components <a class="header-anchor" href="#components" aria-label="Permalink to &quot;Components&quot;">​</a></h3><p>When executed, its <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/Server.java#L193" target="_blank" rel="noreferrer"><code>main()</code></a> method is executed (on the &quot;main&quot; thread). It parses the arguments, establishes the connection with the client and starts the other &quot;components&quot;:</p><ul><li>the <strong>video</strong> streamer: it captures the video screen and send encoded video packets on the <em>video</em> socket (from the <em>video</em> thread).</li><li>the <strong>audio</strong> streamer: it uses several threads to capture raw packets, submits them to encoding and retrieve encoded packets, which it sends on the <em>audio</em> socket.</li><li>the <strong>controller</strong>: it receives <em>control messages</em> (typically input events) on the <em>control</em> socket from one thread, and sends <em>device messages</em> (e.g. to transmit the device clipboard content to the client) on the same <em>control socket</em> from another thread. Thus, the <em>control</em> socket is used in both directions (contrary to the <em>video</em> and <em>audio</em> sockets).</li></ul><h3 id="screen-video-encoding" tabindex="-1">Screen video encoding <a class="header-anchor" href="#screen-video-encoding" aria-label="Permalink to &quot;Screen video encoding&quot;">​</a></h3><p>The encoding is managed by <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/ScreenEncoder.java" target="_blank" rel="noreferrer"><code>ScreenEncoder</code></a>.</p><p>The video is encoded using the <a href="https://developer.android.com/reference/android/media/MediaCodec.html" target="_blank" rel="noreferrer"><code>MediaCodec</code></a> API. The codec encodes the content of a <code>Surface</code> associated to the display, and writes the encoding packets to the client (on the <em>video</em> socket).</p><p>On device rotation (or folding), the encoding session is <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/ScreenEncoder.java#L179" target="_blank" rel="noreferrer">reset</a> and restarted.</p><p>New frames are produced only when changes occur on the surface. This avoids to send unnecessary frames, but by default there might be drawbacks:</p><ul><li>it does not send any frame on start if the device screen does not change,</li><li>after fast motion changes, the last frame may have poor quality.</li></ul><p>Both problems are <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/ScreenEncoder.java#L246-L247" target="_blank" rel="noreferrer">solved</a> by the flag <a href="https://developer.android.com/reference/android/media/MediaFormat.html#KEY_REPEAT_PREVIOUS_FRAME_AFTER" target="_blank" rel="noreferrer"><code>KEY_REPEAT_PREVIOUS_FRAME_AFTER</code></a>.</p><h3 id="audio-encoding" tabindex="-1">Audio encoding <a class="header-anchor" href="#audio-encoding" aria-label="Permalink to &quot;Audio encoding&quot;">​</a></h3><p>Similarly, the audio is <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/AudioCapture.java" target="_blank" rel="noreferrer">captured</a> using an <a href="https://developer.android.com/reference/android/media/AudioRecord" target="_blank" rel="noreferrer"><code>AudioRecord</code></a>, and <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/AudioEncoder.java" target="_blank" rel="noreferrer">encoded</a> using the <a href="https://developer.android.com/reference/android/media/MediaCodec.html" target="_blank" rel="noreferrer"><code>MediaCodec</code></a> asynchronous API.</p><p>More details are available on the <a href="https://blog.rom1v.com/2023/03/scrcpy-2-0-with-audio/" target="_blank" rel="noreferrer">blog post</a> introducing the audio feature.</p><h3 id="input-events-injection" tabindex="-1">Input events injection <a class="header-anchor" href="#input-events-injection" aria-label="Permalink to &quot;Input events injection&quot;">​</a></h3><p><em>Control messages</em> are received from the client by the <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/Controller.java" target="_blank" rel="noreferrer"><code>Controller</code></a> (run in a separate thread). There are several types of input events:</p><ul><li>keycode (cf <a href="https://developer.android.com/reference/android/view/KeyEvent.html" target="_blank" rel="noreferrer"><code>KeyEvent</code></a>),</li><li>text (special characters may not be handled by keycodes directly),</li><li>mouse motion/click,</li><li>mouse scroll,</li><li>other commands (e.g. to switch the screen on or to copy the clipboard).</li></ul><p>Some of them need to inject input events to the system. To do so, they use the <em>hidden</em> method <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/wrappers/InputManager.java#L34" target="_blank" rel="noreferrer"><code>InputManager.injectInputEvent()</code></a> (exposed by the <a href="https://github.com/Genymobile/scrcpy/blob/ffe0417228fb78ab45b7ee4e202fc06fc8875bf3/server/src/main/java/com/genymobile/scrcpy/wrappers/InputManager.java#L27" target="_blank" rel="noreferrer"><code>InputManager</code> wrapper</a>).</p><h2 id="client" tabindex="-1">Client <a class="header-anchor" href="#client" aria-label="Permalink to &quot;Client&quot;">​</a></h2><p>The client relies on <a href="https://www.libsdl.org" target="_blank" rel="noreferrer">SDL</a>, which provides cross-platform API for UI, input events, threading, etc.</p><p>The video and audio streams are decoded by <a href="https://ffmpeg.org/" target="_blank" rel="noreferrer">FFmpeg</a>.</p><h3 id="initialization" tabindex="-1">Initialization <a class="header-anchor" href="#initialization" aria-label="Permalink to &quot;Initialization&quot;">​</a></h3><p>The client parses the command line arguments, then <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/app/src/main.c#L81-L82" target="_blank" rel="noreferrer">runs one of two code paths</a>:</p><ul><li>scrcpy in &quot;normal&quot; mode (<a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/app/src/scrcpy.c#L292-L293" target="_blank" rel="noreferrer"><code>scrcpy.c</code></a>)</li><li>scrcpy in <a href="/reference/scrcpy/otg">OTG mode</a> (<a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/app/src/usb/scrcpy_otg.c#L51-L52" target="_blank" rel="noreferrer"><code>scrcpy_otg.c</code></a>)</li></ul><p>In the remaining of this document, we assume that the &quot;normal&quot; mode is used (read the code for the OTG mode).</p><p>On startup, the client:</p><ul><li>opens the <em>video</em>, <em>audio</em> and <em>control</em> sockets;</li><li>pushes and starts the server on the device;</li><li>initializes its components (demuxers, decoders, recorder…).</li></ul><h3 id="video-and-audio-streams" tabindex="-1">Video and audio streams <a class="header-anchor" href="#video-and-audio-streams" aria-label="Permalink to &quot;Video and audio streams&quot;">​</a></h3><p>Depending on the arguments passed to <code>scrcpy</code>, several components may be used. Here is an overview of the video and audio components:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>                                                 V4L2 sink</span></span>
<span class="line"><span>                                               /</span></span>
<span class="line"><span>                                       decoder</span></span>
<span class="line"><span>                                     /         \\</span></span>
<span class="line"><span>        VIDEO -------------&gt; demuxer             display</span></span>
<span class="line"><span>                                     \\</span></span>
<span class="line"><span>                                       recorder</span></span>
<span class="line"><span>                                     /</span></span>
<span class="line"><span>        AUDIO -------------&gt; demuxer</span></span>
<span class="line"><span>                                     \\</span></span>
<span class="line"><span>                                       decoder --- audio player</span></span></code></pre></div><p>The <em>demuxer</em> is responsible to extract video and audio packets (read some header, split the video stream into packets at correct boundaries, etc.).</p><p>The demuxed packets may be sent to a <em>decoder</em> (one per stream, to produce frames) and to a recorder (receiving both video and audio stream to record a single file). The packets are encoded on the device (by <code>MediaCodec</code>), but when recording, they are <em>muxed</em> (asynchronously) into a container (MKV or MP4) on the client side.</p><p>Video frames are sent to the screen/display to be rendered in the scrcpy window. They may also be sent to a <a href="/reference/scrcpy/v4l2">V4L2 sink</a>.</p><p>Audio &quot;frames&quot; (an array of decoded samples) are sent to the audio player.</p><h3 id="controller" tabindex="-1">Controller <a class="header-anchor" href="#controller" aria-label="Permalink to &quot;Controller&quot;">​</a></h3><p>The <em>controller</em> is responsible to send <em>control messages</em> to the device. It runs in a separate thread, to avoid I/O on the main thread.</p><p>On SDL event, received on the main thread, the <em>input manager</em> creates appropriate <em>control messages</em>. It is responsible to convert SDL events to Android events. It then pushes the <em>control messages</em> to a queue hold by the controller. On its own thread, the controller takes messages from the queue, that it serializes and sends to the client.</p><h2 id="protocol" tabindex="-1">Protocol <a class="header-anchor" href="#protocol" aria-label="Permalink to &quot;Protocol&quot;">​</a></h2><p>The protocol between the client and the server must be considered <em>internal</em>: it may (and will) change at any time for any reason. Everything may change (the number of sockets, the order in which the sockets must be opened, the data format on the wire…) from version to version. A client must always be run with a matching server version.</p><p>This section documents the current protocol in scrcpy v2.1.</p><h3 id="connection" tabindex="-1">Connection <a class="header-anchor" href="#connection" aria-label="Permalink to &quot;Connection&quot;">​</a></h3><p>Firstly, the client sets up an adb tunnel:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># By default, a reverse redirection: the computer listens, the device connects</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> reverse</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> localabstract:scrcpy_</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">SCI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tcp:27183</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># As a fallback (or if --force-adb forward is set), a forward redirection:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># the device listens, the computer connects</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> forward</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tcp:27183</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> localabstract:scrcpy_</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">SCI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p>(<code>&lt;SCID&gt;</code> is a 31-bit random number, so that it does not fail when several scrcpy instances start &quot;at the same time&quot; for the same device.)</p><p>Then, up to 3 sockets are opened, in that order:</p><ul><li>a <em>video</em> socket</li><li>an <em>audio</em> socket</li><li>a <em>control</em> socket</li></ul><p>Each one may be disabled (respectively by <code>--no-video</code>, <code>--no-audio</code> and <code>--no-control</code>, directly or indirectly). For example, if <code>--no-audio</code> is set, then the <em>video</em> socket is opened first, then the <em>control</em> socket.</p><p>On the <em>first</em> socket opened (whichever it is), if the tunnel is <em>forward</em>, then a <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/DesktopConnection.java#L93" target="_blank" rel="noreferrer">dummy byte</a> is sent from the device to the client. This allows to detect a connection error (the client connection does not fail as long as there is an adb forward redirection, even if nothing is listening on the device side).</p><p>Still on this <em>first</em> socket, the device sends some <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/DesktopConnection.java#L151" target="_blank" rel="noreferrer">metadata</a> to the client (currently only the device name, used as the window title, but there might be other fields in the future).</p><p>You can read the <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/app/src/server.c#L465-L466" target="_blank" rel="noreferrer">client</a> and <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/DesktopConnection.java#L63" target="_blank" rel="noreferrer">server</a> code for more details.</p><p>Then each socket is used for its intended purpose.</p><h3 id="video-and-audio" tabindex="-1">Video and audio <a class="header-anchor" href="#video-and-audio" aria-label="Permalink to &quot;Video and audio&quot;">​</a></h3><p>On the <em>video</em> and <em>audio</em> sockets, the device first sends some <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/Streamer.java#L33-L51" target="_blank" rel="noreferrer">codec metadata</a>:</p><ul><li>On the <em>video</em> socket, 12 bytes: <ul><li>the codec id (<code>u32</code>) (H264, H265 or AV1)</li><li>the initial video width (<code>u32</code>)</li><li>the initial video height (<code>u32</code>)</li></ul></li><li>On the <em>audio</em> socket, 4 bytes: <ul><li>the codec id (<code>u32</code>) (OPUS, AAC or RAW)</li></ul></li></ul><p>Then each packet produced by <code>MediaCodec</code> is sent, prefixed by a 12-byte <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/Streamer.java#L83" target="_blank" rel="noreferrer">frame header</a>:</p><ul><li>config packet flag (<code>u1</code>)</li><li>key frame flag (<code>u1</code>)</li><li>PTS (<code>u62</code>)</li><li>packet size (<code>u32</code>)</li></ul><p>Here is a schema describing the frame header:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>    [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...</span></span>
<span class="line"><span>     &lt;-------------&gt; &lt;-----&gt; &lt;-----------------------------...</span></span>
<span class="line"><span>           PTS        packet        raw packet</span></span>
<span class="line"><span>                       size</span></span>
<span class="line"><span>     &lt;---------------------&gt;</span></span>
<span class="line"><span>           frame header</span></span>
<span class="line"><span></span></span>
<span class="line"><span>The most significant bits of the PTS are used for packet flags:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>     byte 7   byte 6   byte 5   byte 4   byte 3   byte 2   byte 1   byte 0</span></span>
<span class="line"><span>    CK...... ........ ........ ........ ........ ........ ........ ........</span></span>
<span class="line"><span>    ^^&lt;-------------------------------------------------------------------&gt;</span></span>
<span class="line"><span>    ||                                PTS</span></span>
<span class="line"><span>    | \`- key frame</span></span>
<span class="line"><span>     \`-- config packet</span></span></code></pre></div><h3 id="controls" tabindex="-1">Controls <a class="header-anchor" href="#controls" aria-label="Permalink to &quot;Controls&quot;">​</a></h3><p>Controls messages are sent via a custom binary protocol.</p><p>The only documentation for this protocol is the set of unit tests on both sides:</p><ul><li><code>ControlMessage</code> (from client to device): <a href="https://github.com/Genymobile/scrcpy/blob/master/app/tests/test_control_msg_serialize.c" target="_blank" rel="noreferrer">serialization</a> | <a href="https://github.com/Genymobile/scrcpy/blob/master/server/src/test/java/com/genymobile/scrcpy/ControlMessageReaderTest.java" target="_blank" rel="noreferrer">deserialization</a></li><li><code>DeviceMessage</code> (from device to client) <a href="https://github.com/Genymobile/scrcpy/blob/master/server/src/test/java/com/genymobile/scrcpy/DeviceMessageWriterTest.java" target="_blank" rel="noreferrer">serialization</a> | <a href="https://github.com/Genymobile/scrcpy/blob/master/app/tests/test_device_msg_deserialize.c" target="_blank" rel="noreferrer">deserialization</a></li></ul><h2 id="standalone-server" tabindex="-1">Standalone server <a class="header-anchor" href="#standalone-server" aria-label="Permalink to &quot;Standalone server&quot;">​</a></h2><p>Although the server is designed to work for the scrcpy client, it can be used with any client which uses the same protocol.</p><p>For simplicity, some <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/Options.java#L309-L329" target="_blank" rel="noreferrer">server-specific options</a> have been added to produce raw streams easily:</p><ul><li><code>send_device_meta=false</code>: disable the device metata (in practice, the device name) sent on the <em>first</em> socket</li><li><code>send_frame_meta=false</code>: disable the 12-byte header for each packet</li><li><code>send_dummy_byte</code>: disable the dummy byte sent on forward connections</li><li><code>send_codec_meta</code>: disable the codec information (and initial device size for video)</li><li><code>raw_stream</code>: disable all the above</li></ul><p>Concretely, here is how to expose a raw H.264 stream on a TCP socket:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> scrcpy-server-v2.1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /data/local/tmp/scrcpy-server-manual.jar</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> forward</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tcp:1234</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> localabstract:scrcpy</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> shell</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> CLASSPATH=/data/local/tmp/scrcpy-server-manual.jar</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    app_process</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> com.genymobile.scrcpy.Server</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.1</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    tunnel_forward=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> audio=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> control=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cleanup=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    raw_stream=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> max_size=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1920</span></span></code></pre></div><p>As soon as a client connects over TCP on port 1234, the device will start streaming the video. For example, VLC can play the video (although you will experience a very high latency, more details <a href="https://code.videolan.org/rom1v/vlc/-/merge_requests/20" target="_blank" rel="noreferrer">here</a>):</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>vlc -Idummy --demux=h264 --network-caching=0 tcp://localhost:1234</span></span></code></pre></div><h2 id="hack" tabindex="-1">Hack <a class="header-anchor" href="#hack" aria-label="Permalink to &quot;Hack&quot;">​</a></h2><p>For more details, go read the code!</p><p>If you find a bug, or have an awesome idea to implement, please discuss and contribute 😉</p><h3 id="debug-the-server" tabindex="-1">Debug the server <a class="header-anchor" href="#debug-the-server" aria-label="Permalink to &quot;Debug the server&quot;">​</a></h3><p>The server is pushed to the device by the client on startup.</p><p>To debug it, enable the server debugger during configuration:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">meson</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> setup</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Dserver_debugger=true</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># or, if x is already configured</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">meson</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> configure</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Dserver_debugger=true</span></span></code></pre></div><p>Then recompile, and run scrcpy.</p><p>For Android &lt; 11, it will start a debugger on port 5005 on the device and wait: Redirect that port to the computer:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> forward</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tcp:5005</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tcp:5005</span></span></code></pre></div><p>For Android &gt;= 11, first find the listening port:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> jdwp</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># press Ctrl+C to interrupt</span></span></code></pre></div><p>Then redirect the resulting PID:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> forward</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tcp:5005</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> jdwp:XXXX</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # replace XXXX</span></span></code></pre></div><p>In Android Studio, <em>Run</em> &gt; <em>Debug</em> &gt; <em>Edit configurations...</em> On the left, click on <code>+</code>, <em>Remote</em>, and fill the form:</p><ul><li>Host: <code>localhost</code></li><li>Port: <code>5005</code></li></ul><p>Then click on <em>Debug</em>.</p>`,119),r=[n];function o(c,l,d,h,p,m){return s(),a("div",null,r)}const u=e(t,[["render",o]]);export{k as __pageData,u as default};
