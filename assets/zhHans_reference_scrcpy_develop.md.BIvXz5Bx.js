import{_ as a,c as e,o as s,aj as i}from"./chunks/framework.MtKKuSHf.js";const m=JSON.parse('{"title":"develop（开发者指南）","description":"","frontmatter":{"title":"develop（开发者指南）"},"headers":[],"relativePath":"zhHans/reference/scrcpy/develop.md","filePath":"zhHans/reference/scrcpy/develop.md","lastUpdated":1745766736000}'),r={name:"zhHans/reference/scrcpy/develop.md"},l=i(`<h1 id="开发者指南-scrcpy" tabindex="-1">开发者指南：scrcpy <a class="header-anchor" href="#开发者指南-scrcpy" aria-label="Permalink to &quot;开发者指南：scrcpy&quot;">​</a></h1><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><p>该应用由两部分组成：</p><ul><li>服务端（<code>scrcpy-server</code>），在设备上执行；</li><li>客户端（<code>scrcpy</code> 可执行文件），在主机上执行。</li></ul><p>客户端负责将服务端推送到设备并启动其执行。</p><p>客户端和服务端通过独立的套接字进行视频、音频和控制通信。这些功能可以单独禁用（但不能全部禁用），因此可能使用 1、2 或 3 个套接字。</p><p>服务端首先在第一个套接字上发送设备名称（用于 scrcpy 窗口标题），随后每个套接字分别用于其特定用途。客户端和服务端均为每个套接字分配专用线程进行读写操作。</p><p>如果启用了视频功能，服务端会发送设备屏幕的原始视频流（默认为 H.264 编码），每个数据包附带额外头部信息。客户端解码视频帧并尽快显示，不进行缓冲（除非指定 <code>--video-buffer=delay</code>）以最小化延迟。客户端不感知设备旋转（由服务端处理），仅知道接收到的视频帧尺寸。</p><p>类似地，如果启用了音频功能，服务端会发送设备音频输出（或通过 <code>--audio-source=mic</code> 指定麦克风输入）的原始音频流（默认为 OPUS 编码），每个数据包附带额外头部信息。客户端解码音频流，尝试通过保持最小缓冲来降低延迟。<a href="https://blog.rom1v.com/2023/03/scrcpy-2-0-with-audio/" target="_blank" rel="noreferrer">scrcpy v2.0 发布的博客文章</a>详细介绍了音频功能。</p><p>如果启用了控制功能，客户端会捕获相关的键盘和鼠标事件，并将其传输到服务端，由服务端注入到设备中。这是唯一一个双向使用的套接字：输入事件从客户端发送到设备，而当设备剪贴板内容变化时，新内容会从设备发送到客户端，以实现无缝复制粘贴。</p><p>需要注意的是，客户端和服务端的角色是从应用层面定义的：</p><ul><li>服务端提供视频和音频流，并处理客户端的请求；</li><li>客户端通过服务端控制设备。</li></ul><p>然而，默认情况下（未设置 <code>--force-adb-forward</code> 时），网络层面的角色是相反的：</p><ul><li>客户端在启动服务端之前打开服务器套接字并监听端口；</li><li>服务端连接到客户端。</li></ul><p>这种角色反转避免了因竞态条件导致的连接失败，而无需轮询。</p><hr><h2 id="服务端" tabindex="-1">服务端 <a class="header-anchor" href="#服务端" aria-label="Permalink to &quot;服务端&quot;">​</a></h2><h3 id="权限" tabindex="-1">权限 <a class="header-anchor" href="#权限" aria-label="Permalink to &quot;权限&quot;">​</a></h3><p>捕获屏幕需要一些权限，这些权限已授予 <code>shell</code> 用户。</p><p>服务端是一个 Java 应用程序（包含 <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/Server.java#L193" target="_blank" rel="noreferrer"><code>public static void main(String... args)</code></a> 方法），针对 Android 框架编译，并在 Android 设备上以 <code>shell</code> 用户身份执行。</p><p>要运行这样的 Java 应用程序，类必须被 <a href="https://en.wikipedia.org/wiki/Dalvik_(software)" target="_blank" rel="noreferrer"><em>dexed</em></a>（通常是 <code>classes.dex</code>）。如果 <code>my.package.MainClass</code> 是主类，编译为 <code>classes.dex</code> 并推送到设备的 <code>/data/local/tmp</code> 目录，则可以通过以下命令运行：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> shell</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> CLASSPATH=/data/local/tmp/classes.dex</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app_process</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> my.package.MainClass</span></span></code></pre></div><p><em>路径 <code>/data/local/tmp</code> 是推送服务端的理想选择，因为它对 <code>shell</code> 用户可读写，但对其他用户不可写，因此恶意应用无法在客户端执行前替换服务端。</em></p><p>除了原始的 <em>dex</em> 文件，<code>app_process</code> 还接受包含 <code>classes.dex</code> 的 <em>jar</em> 文件（例如 <a href="https://en.wikipedia.org/wiki/Android_application_package" target="_blank" rel="noreferrer">APK</a>）。为了简化操作并利用 gradle 构建系统，服务端被构建为一个（未签名的）APK（重命名为 <code>scrcpy-server.jar</code>）。</p><h3 id="隐藏方法" tabindex="-1">隐藏方法 <a class="header-anchor" href="#隐藏方法" aria-label="Permalink to &quot;隐藏方法&quot;">​</a></h3><p>尽管针对 Android 框架编译，<a href="https://stackoverflow.com/a/31908373/1987178" target="_blank" rel="noreferrer">隐藏</a>方法和类无法直接访问（且不同 Android 版本可能有所不同）。</p><p>可以通过反射调用这些方法。与隐藏组件的通信由 <a href="https://github.com/Genymobile/scrcpy/tree/master/server/src/main/java/com/genymobile/scrcpy/wrappers" target="_blank" rel="noreferrer"><em>wrapper</em> 类</a> 和 <a href="https://github.com/Genymobile/scrcpy/tree/master/server/src/main/aidl" target="_blank" rel="noreferrer">aidl</a> 提供。</p><h3 id="执行" tabindex="-1">执行 <a class="header-anchor" href="#执行" aria-label="Permalink to &quot;执行&quot;">​</a></h3><p>客户端通过以下命令启动服务端：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> scrcpy-server</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /data/local/tmp/scrcpy-server.jar</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> forward</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tcp:27183</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> localabstract:scrcpy</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> shell</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> CLASSPATH=/data/local/tmp/scrcpy-server.jar</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app_process</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> com.genymobile.scrcpy.Server</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.1</span></span></code></pre></div><p>第一个参数（示例中的 <code>2.1</code>）是客户端的 scrcpy 版本。如果客户端和服务端版本不完全一致，服务端会失败。客户端和服务端之间的协议可能因版本而异（参见<a href="#协议">协议</a>部分），且没有向后或向前兼容性（使用不同版本的服务端和客户端毫无意义）。此检查用于检测配置错误（意外运行旧版或新版服务端）。</p><p>随后可以跟随任意数量的参数，形式为 <code>key=value</code> 对，顺序无关。可能的键及其值类型可以在<a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/Options.java#L181" target="_blank" rel="noreferrer">服务端</a>和<a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/app/src/server.c#L226" target="_blank" rel="noreferrer">客户端</a>代码中找到。</p><p>例如，如果执行 <code>scrcpy -m1920 --no-audio</code>，则服务端的执行如下：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># scid 是一个随机数，用于区分同一设备上运行的不同客户端</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> shell</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> CLASSPATH=/data/local/tmp/scrcpy-server.jar</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app_process</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> com.genymobile.scrcpy.Server</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> scid=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12345678</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> log_level=info</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> audio=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> max_size=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1920</span></span></code></pre></div><h3 id="组件" tabindex="-1">组件 <a class="header-anchor" href="#组件" aria-label="Permalink to &quot;组件&quot;">​</a></h3><p>执行时，其 <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/Server.java#L193" target="_blank" rel="noreferrer"><code>main()</code></a> 方法（在“主”线程中运行）会解析参数，建立与客户端的连接，并启动其他“组件”：</p><ul><li><strong>视频</strong>流：捕获屏幕视频并通过 <em>video</em> 套接字发送编码后的视频数据包（从 <em>video</em> 线程）。</li><li><strong>音频</strong>流：使用多个线程捕获原始数据包，提交编码并获取编码后的数据包，通过 <em>audio</em> 套接字发送。</li><li><strong>控制器</strong>：从一个线程接收 <em>control</em> 套接字上的控制消息（通常是输入事件），并从另一个线程通过同一 <em>control</em> 套接字发送设备消息（例如将设备剪贴板内容传输到客户端）。因此，<em>control</em> 套接字是双向使用的（与 <em>video</em> 和 <em>audio</em> 套接字不同）。</li></ul><h3 id="屏幕视频编码" tabindex="-1">屏幕视频编码 <a class="header-anchor" href="#屏幕视频编码" aria-label="Permalink to &quot;屏幕视频编码&quot;">​</a></h3><p>编码由 <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/ScreenEncoder.java" target="_blank" rel="noreferrer"><code>ScreenEncoder</code></a> 管理。</p><p>视频使用 <a href="https://developer.android.com/reference/android/media/MediaCodec.html" target="_blank" rel="noreferrer"><code>MediaCodec</code></a> API 编码。编码器编码与显示关联的 <code>Surface</code> 内容，并将编码后的数据包写入客户端（通过 <em>video</em> 套接字）。</p><p>在设备旋转（或折叠）时，编码会话会<a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/ScreenEncoder.java#L179" target="_blank" rel="noreferrer">重置</a>并重新启动。</p><p>仅当 Surface 发生变化时才会生成新帧。这避免了发送不必要的帧，但默认情况下可能存在以下问题：</p><ul><li>如果设备屏幕未变化，启动时不会发送任何帧；</li><li>快速运动变化后，最后一帧的质量可能较差。</li></ul><p>这两个问题通过标志 <a href="https://developer.android.com/reference/android/media/MediaFormat.html#KEY_REPEAT_PREVIOUS_FRAME_AFTER" target="_blank" rel="noreferrer"><code>KEY_REPEAT_PREVIOUS_FRAME_AFTER</code></a> <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/ScreenEncoder.java#L246-L247" target="_blank" rel="noreferrer">解决</a>。</p><h3 id="音频编码" tabindex="-1">音频编码 <a class="header-anchor" href="#音频编码" aria-label="Permalink to &quot;音频编码&quot;">​</a></h3><p>类似地，音频通过 <a href="https://developer.android.com/reference/android/media/AudioRecord" target="_blank" rel="noreferrer"><code>AudioRecord</code></a> <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/AudioCapture.java" target="_blank" rel="noreferrer">捕获</a>，并使用 <a href="https://developer.android.com/reference/android/media/MediaCodec.html" target="_blank" rel="noreferrer"><code>MediaCodec</code></a> 异步 API <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/AudioEncoder.java" target="_blank" rel="noreferrer">编码</a>。</p><p>更多细节请参阅介绍音频功能的<a href="https://blog.rom1v.com/2023/03/scrcpy-2-0-with-audio/" target="_blank" rel="noreferrer">博客文章</a>。</p><h3 id="输入事件注入" tabindex="-1">输入事件注入 <a class="header-anchor" href="#输入事件注入" aria-label="Permalink to &quot;输入事件注入&quot;">​</a></h3><p><em>控制消息</em> 由客户端通过 <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/Controller.java" target="_blank" rel="noreferrer"><code>Controller</code></a>（在单独线程中运行）接收。输入事件有多种类型：</p><ul><li>键码（参考 <a href="https://developer.android.com/reference/android/view/KeyEvent.html" target="_blank" rel="noreferrer"><code>KeyEvent</code></a>）；</li><li>文本（特殊字符可能无法直接通过键码处理）；</li><li>鼠标移动/点击；</li><li>鼠标滚动；</li><li>其他命令（例如开关屏幕或复制剪贴板）。</li></ul><p>其中一些需要通过系统注入输入事件。为此，它们使用 <em>隐藏</em> 方法 <a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/wrappers/InputManager.java#L34" target="_blank" rel="noreferrer"><code>InputManager.injectInputEvent()</code></a>（由 <a href="https://github.com/Genymobile/scrcpy/blob/ffe0417228fb78ab45b7ee4e202fc06fc8875bf3/server/src/main/java/com/genymobile/scrcpy/wrappers/InputManager.java#L27" target="_blank" rel="noreferrer"><code>InputManager</code> 包装器</a> 暴露）。</p><hr><h2 id="客户端" tabindex="-1">客户端 <a class="header-anchor" href="#客户端" aria-label="Permalink to &quot;客户端&quot;">​</a></h2><p>客户端依赖 <a href="https://www.libsdl.org" target="_blank" rel="noreferrer">SDL</a>，它提供了跨平台的 UI、输入事件、线程等 API。</p><p>视频和音频流由 <a href="https://ffmpeg.org/" target="_blank" rel="noreferrer">FFmpeg</a> 解码。</p><h3 id="初始化" tabindex="-1">初始化 <a class="header-anchor" href="#初始化" aria-label="Permalink to &quot;初始化&quot;">​</a></h3><p>客户端解析命令行参数后，<a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/app/src/main.c#L81-L82" target="_blank" rel="noreferrer">运行以下两种代码路径之一</a>：</p><ul><li>scrcpy 的“正常”模式（<a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/app/src/scrcpy.c#L292-L293" target="_blank" rel="noreferrer"><code>scrcpy.c</code></a>）；</li><li>scrcpy 的 <a href="/zhHans/reference/scrcpy/otg">OTG 模式</a>（<a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/app/src/usb/scrcpy_otg.c#L51-L52" target="_blank" rel="noreferrer"><code>scrcpy_otg.c</code></a>）。</li></ul><p>在本文档的剩余部分，我们假设使用的是“正常”模式（OTG 模式的代码请自行阅读）。</p><p>启动时，客户端：</p><ul><li>打开 <em>video</em>、<em>audio</em> 和 <em>control</em> 套接字；</li><li>推送并启动设备上的服务端；</li><li>初始化其组件（解复用器、解码器、录制器等）。</li></ul><h3 id="视频和音频流" tabindex="-1">视频和音频流 <a class="header-anchor" href="#视频和音频流" aria-label="Permalink to &quot;视频和音频流&quot;">​</a></h3><p>根据传递给 <code>scrcpy</code> 的参数，可能会使用多个组件。以下是视频和音频组件的概述：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>                                                 V4L2 sink</span></span>
<span class="line"><span>                                               /</span></span>
<span class="line"><span>                                       decoder</span></span>
<span class="line"><span>                                     /         \\</span></span>
<span class="line"><span>        VIDEO -------------&gt; demuxer             display</span></span>
<span class="line"><span>                                     \\</span></span>
<span class="line"><span>                                       recorder</span></span>
<span class="line"><span>                                     /</span></span>
<span class="line"><span>        AUDIO -------------&gt; demuxer</span></span>
<span class="line"><span>                                     \\</span></span>
<span class="line"><span>                                       decoder --- audio player</span></span></code></pre></div><p><em>解复用器</em> 负责提取视频和音频数据包（读取头部信息，在正确边界处拆分视频流等）。</p><p>解复用后的数据包可能发送到 <em>解码器</em>（每个流一个，用于生成帧）和录制器（接收视频和音频流以录制单个文件）。数据包在设备上编码（通过 <code>MediaCodec</code>），但在录制时，它们会在客户端异步 <em>复用</em> 到容器（MKV 或 MP4）中。</p><p>视频帧发送到屏幕/显示器以在 scrcpy 窗口中渲染，也可能发送到 <a href="/zhHans/reference/scrcpy/v4l2">V4L2 sink</a>。</p><p>音频“帧”（解码后的样本数组）发送到音频播放器。</p><h3 id="控制器" tabindex="-1">控制器 <a class="header-anchor" href="#控制器" aria-label="Permalink to &quot;控制器&quot;">​</a></h3><p><em>控制器</em> 负责向设备发送 <em>控制消息</em>。它在单独的线程中运行，以避免在主线程上进行 I/O 操作。</p><p>在主线程上接收 SDL 事件时，<em>输入管理器</em> 会创建相应的 <em>控制消息</em>。它负责将 SDL 事件转换为 Android 事件，然后将 <em>控制消息</em> 推送到控制器持有的队列中。控制器在自己的线程中从队列中取出消息，序列化后发送到客户端。</p><hr><h2 id="协议" tabindex="-1">协议 <a class="header-anchor" href="#协议" aria-label="Permalink to &quot;协议&quot;">​</a></h2><p>客户端和服务端之间的协议应视为 <em>内部</em>：它可能（并且将会）因任何原因随时更改。所有内容（套接字数量、套接字打开顺序、数据格式等）都可能因版本而异。客户端必须始终与匹配的服务端版本一起运行。</p><p>本节记录了 scrcpy v2.1 的当前协议。</p><h3 id="连接" tabindex="-1">连接 <a class="header-anchor" href="#连接" aria-label="Permalink to &quot;连接&quot;">​</a></h3><p>首先，客户端设置 adb 隧道：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 默认情况下是反向重定向：计算机监听，设备连接</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> reverse</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> localabstract:scrcpy_</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">SCI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tcp:27183</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 作为回退（或设置了 --force-adb forward 时），是正向重定向：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 设备监听，计算机连接</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> forward</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tcp:27183</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> localabstract:scrcpy_</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">SCI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p>（<code>&lt;SCID&gt;</code> 是一个 31 位随机数，以避免同一设备上同时启动多个 scrcpy 实例时失败。）</p><p>随后，按顺序打开最多 3 个套接字：</p><ul><li><em>video</em> 套接字；</li><li><em>audio</em> 套接字；</li><li><em>control</em> 套接字。</li></ul><p>每个套接字都可以禁用（分别通过 <code>--no-video</code>、<code>--no-audio</code> 和 <code>--no-control</code>，直接或间接）。例如，如果设置了 <code>--no-audio</code>，则首先打开 <em>video</em> 套接字，然后是 <em>control</em> 套接字。</p><p>在打开的 <em>第一个</em> 套接字上（无论哪个），如果隧道是 <em>正向</em> 的，则设备会向客户端发送一个<a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/DesktopConnection.java#L93" target="_blank" rel="noreferrer">虚拟字节</a>。这用于检测连接错误（只要存在 adb 正向重定向，客户端连接就不会失败，即使设备端没有监听）。</p><p>仍然在此 <em>第一个</em> 套接字上，设备向客户端发送一些<a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/DesktopConnection.java#L151" target="_blank" rel="noreferrer">元数据</a>（目前仅设备名称，用作窗口标题，但未来可能包含其他字段）。</p><p>更多细节请阅读<a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/app/src/server.c#L465-L466" target="_blank" rel="noreferrer">客户端</a>和<a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/DesktopConnection.java#L63" target="_blank" rel="noreferrer">服务端</a>代码。</p><p>随后，每个套接字用于其预定用途。</p><h3 id="视频和音频" tabindex="-1">视频和音频 <a class="header-anchor" href="#视频和音频" aria-label="Permalink to &quot;视频和音频&quot;">​</a></h3><p>在 <em>video</em> 和 <em>audio</em> 套接字上，设备首先发送一些<a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/Streamer.java#L33-L51" target="_blank" rel="noreferrer">编解码器元数据</a>：</p><ul><li>在 <em>video</em> 套接字上，12 字节： <ul><li>编解码器 ID（<code>u32</code>）（H264、H265 或 AV1）；</li><li>初始视频宽度（<code>u32</code>）；</li><li>初始视频高度（<code>u32</code>）。</li></ul></li><li>在 <em>audio</em> 套接字上，4 字节： <ul><li>编解码器 ID（<code>u32</code>）（OPUS、AAC 或 RAW）。</li></ul></li></ul><p>随后，每个由 <code>MediaCodec</code> 生成的数据包会附带一个 12 字节的<a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/Streamer.java#L83" target="_blank" rel="noreferrer">帧头部</a>：</p><ul><li>配置包标志（<code>u1</code>）；</li><li>关键帧标志（<code>u1</code>）；</li><li>PTS（<code>u62</code>）；</li><li>数据包大小（<code>u32</code>）。</li></ul><p>以下是帧头部的结构描述：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>    [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...</span></span>
<span class="line"><span>     &lt;-------------&gt; &lt;-----&gt; &lt;-----------------------------...</span></span>
<span class="line"><span>           PTS        packet        raw packet</span></span>
<span class="line"><span>                       size</span></span>
<span class="line"><span>     &lt;---------------------&gt;</span></span>
<span class="line"><span>           frame header</span></span>
<span class="line"><span></span></span>
<span class="line"><span>PTS 的最高位用于数据包标志：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>     byte 7   byte 6   byte 5   byte 4   byte 3   byte 2   byte 1   byte 0</span></span>
<span class="line"><span>    CK...... ........ ........ ........ ........ ........ ........ ........</span></span>
<span class="line"><span>    ^^&lt;-------------------------------------------------------------------&gt;</span></span>
<span class="line"><span>    ||                                PTS</span></span>
<span class="line"><span>    | \`- 关键帧</span></span>
<span class="line"><span>     \`-- 配置包</span></span></code></pre></div><h3 id="控制" tabindex="-1">控制 <a class="header-anchor" href="#控制" aria-label="Permalink to &quot;控制&quot;">​</a></h3><p>控制消息通过自定义二进制协议发送。</p><p>该协议的唯一文档是双方的单元测试：</p><ul><li><code>ControlMessage</code>（从客户端到设备）：<a href="https://github.com/Genymobile/scrcpy/blob/master/app/tests/test_control_msg_serialize.c" target="_blank" rel="noreferrer">序列化</a> | <a href="https://github.com/Genymobile/scrcpy/blob/master/server/src/test/java/com/genymobile/scrcpy/ControlMessageReaderTest.java" target="_blank" rel="noreferrer">反序列化</a>；</li><li><code>DeviceMessage</code>（从设备到客户端）：<a href="https://github.com/Genymobile/scrcpy/blob/master/server/src/test/java/com/genymobile/scrcpy/DeviceMessageWriterTest.java" target="_blank" rel="noreferrer">序列化</a> | <a href="https://github.com/Genymobile/scrcpy/blob/master/app/tests/test_device_msg_deserialize.c" target="_blank" rel="noreferrer">反序列化</a>。</li></ul><hr><h2 id="独立服务端" tabindex="-1">独立服务端 <a class="header-anchor" href="#独立服务端" aria-label="Permalink to &quot;独立服务端&quot;">​</a></h2><p>尽管服务端设计用于 scrcpy 客户端，但它可以与任何使用相同协议的客户端一起使用。</p><p>为了简化操作，添加了一些<a href="https://github.com/Genymobile/scrcpy/blob/a3cdf1a6b86ea22786e1f7d09b9c202feabc6949/server/src/main/java/com/genymobile/scrcpy/Options.java#L309-L329" target="_blank" rel="noreferrer">服务端特定选项</a>以轻松生成原始流：</p><ul><li><code>send_device_meta=false</code>：禁用通过 <em>第一个</em> 套接字发送的设备元数据（实际为设备名称）；</li><li><code>send_frame_meta=false</code>：禁用每个数据包的 12 字节头部；</li><li><code>send_dummy_byte</code>：禁用正向连接时发送的虚拟字节；</li><li><code>send_codec_meta</code>：禁用编解码信息（以及视频的初始设备尺寸）；</li><li><code>raw_stream</code>：禁用上述所有内容。</li></ul><p>具体来说，以下是如何在 TCP 套接字上暴露原始 H.264 流：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> scrcpy-server-v2.1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /data/local/tmp/scrcpy-server-manual.jar</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> forward</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tcp:1234</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> localabstract:scrcpy</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> shell</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> CLASSPATH=/data/local/tmp/scrcpy-server-manual.jar</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    app_process</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> com.genymobile.scrcpy.Server</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.1</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    tunnel_forward=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> audio=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> control=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cleanup=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    raw_stream=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> max_size=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1920</span></span></code></pre></div><p>一旦客户端通过 TCP 连接到端口 1234，设备就会开始流式传输视频。例如，VLC 可以播放视频（尽管会有很高的延迟，更多细节<a href="https://code.videolan.org/rom1v/vlc/-/merge_requests/20" target="_blank" rel="noreferrer">在此</a>）：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vlc</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Idummy</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --demux=h264</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --network-caching=0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tcp://localhost:1234</span></span></code></pre></div><hr><h2 id="黑客指南" tabindex="-1">黑客指南 <a class="header-anchor" href="#黑客指南" aria-label="Permalink to &quot;黑客指南&quot;">​</a></h2><p>更多细节，请阅读代码！</p><p>如果发现错误或有绝妙的想法，欢迎讨论和贡献 😉</p><h3 id="调试服务端" tabindex="-1">调试服务端 <a class="header-anchor" href="#调试服务端" aria-label="Permalink to &quot;调试服务端&quot;">​</a></h3><p>服务端由客户端在启动时推送到设备。</p><p>要调试它，请在配置时启用服务端调试器：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">meson</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> setup</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Dserver_debugger=true</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 或者，如果 x 已配置</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">meson</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> configure</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Dserver_debugger=true</span></span></code></pre></div><p>然后重新编译并运行 scrcpy。</p><p>对于 Android &lt; 11，它会在设备的 5005 端口启动调试器并等待。将该端口重定向到计算机：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> forward</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tcp:5005</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tcp:5005</span></span></code></pre></div><p>对于 Android &gt;= 11，首先找到监听端口：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> jdwp</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 按 Ctrl+C 中断</span></span></code></pre></div><p>然后重定向结果 PID：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> forward</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tcp:5005</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> jdwp:XXXX</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 替换 XXXX</span></span></code></pre></div><p>在 Android Studio 中，<em>Run</em> &gt; <em>Debug</em> &gt; <em>Edit configurations...</em>，在左侧点击 <code>+</code>，选择 <em>Remote</em>，并填写表单：</p><ul><li>Host: <code>localhost</code>；</li><li>Port: <code>5005</code>。</li></ul><p>然后点击 <em>Debug</em>。</p>`,124),n=[l];function p(t,c,h,o,d,k){return s(),e("div",null,n)}const g=a(r,[["render",p]]);export{m as __pageData,g as default};
